"""Pattern library for known exploits and vulnerabilities."""

from typing import Dict, List, Any, Optional
import re


class ExploitPattern:
    """Represents a known exploit pattern."""

    def __init__(self, name: str, pattern_type: str, signature: bytes,
                 description: str, severity: str, cve: Optional[str] = None):
        self.name = name
        self.pattern_type = pattern_type
        self.signature = signature
        self.description = description
        self.severity = severity
        self.cve = cve

    def matches(self, data: bytes) -> List[int]:
        """Find all matches of this pattern in the data."""
        matches = []
        pos = 0
        while True:
            pos = data.find(self.signature, pos)
            if pos == -1:
                break
            matches.append(pos)
            pos += 1
        return matches


class ExploitPatternLibrary:
    """Library of known exploit patterns."""

    def __init__(self):
        self.patterns = self._load_patterns()

    def _load_patterns(self) -> List[ExploitPattern]:
        """Load known exploit patterns."""
        return [
            # Buffer overflow patterns
            ExploitPattern(
                name="Stack Buffer Overflow",
                pattern_type="buffer_overflow",
                signature=b'\x90\x90\x90\x90' * 10,  # NOP sled
                description="NOP sled followed by shellcode - classic buffer overflow",
                severity="critical",
                cve="CVE-2000-0001"
            ),

            # Format string vulnerabilities
            ExploitPattern(
                name="Format String Vulnerability",
                pattern_type="format_string",
                signature=b'%08x%08x%08x%08x',
                description="Multiple format specifiers - potential format string attack",
                severity="high",
                cve="CVE-2000-0002"
            ),

            # SQL injection patterns (in binary form)
            ExploitPattern(
                name="SQL Injection Attempt",
                pattern_type="injection",
                signature=b"SELECT * FROM users WHERE id = '",
                description="Embedded SQL query - potential injection vulnerability",
                severity="high",
                cve="CVE-2000-0003"
            ),

            # Shellcode patterns
            ExploitPattern(
                name="Linux x86 Shellcode",
                pattern_type="shellcode",
                signature=b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80',
                description="Linux x86 execve shellcode",
                severity="critical",
                cve="CVE-2000-0004"
            ),

            # Heap exploitation
            ExploitPattern(
                name="Heap Feng Shui",
                pattern_type="heap_exploit",
                signature=b'\x00' * 100 + b'\xff' * 4,  # Heap metadata corruption
                description="Heap metadata corruption pattern",
                severity="high",
                cve="CVE-2000-0005"
            ),

            # Use-after-free patterns
            ExploitPattern(
                name="Use After Free",
                pattern_type="use_after_free",
                signature=b'\x00\x00\x00\x00\x01\x00\x00\x00',  # Freed object pattern
                description="Potential use-after-free vulnerability",
                severity="high",
                cve="CVE-2000-0006"
            ),

            # ROP gadgets
            ExploitPattern(
                name="ROP Gadget",
                pattern_type="rop",
                signature=b'\xc3\x90\x90\x90',  # RET followed by NOPs
                description="Return-oriented programming gadget",
                severity="high",
                cve="CVE-2000-0007"
            ),

            # Command injection
            ExploitPattern(
                name="Command Injection",
                pattern_type="injection",
                signature=b'; rm -rf /',
                description="Command injection with destructive command",
                severity="critical",
                cve="CVE-2000-0008"
            ),

            # Path traversal
            ExploitPattern(
                name="Path Traversal",
                pattern_type="directory_traversal",
                signature=b'../../../etc/passwd',
                description="Directory traversal attack",
                severity="high",
                cve="CVE-2000-0009"
            ),

            # XSS in binary (stored patterns)
            ExploitPattern(
                name="Stored XSS",
                pattern_type="xss",
                signature=b'<script>alert(1)</script>',
                description="Cross-site scripting payload",
                severity="medium",
                cve="CVE-2000-0010"
            )
        ]

    def scan_binary(self, binary_data: bytes) -> Dict[str, Any]:
        """
        Scan binary data for known exploit patterns.

        Returns:
            Dictionary containing detected patterns and their locations
        """
        detected_patterns = []

        for pattern in self.patterns:
            matches = pattern.matches(binary_data)
            if matches:
                detected_patterns.append({
                    "pattern_name": pattern.name,
                    "pattern_type": pattern.pattern_type,
                    "severity": pattern.severity,
                    "description": pattern.description,
                    "cve": pattern.cve,
                    "locations": [f"0x{pos:08X}" for pos in matches],
                    "match_count": len(matches),
                    "signature": pattern.signature.hex()
                })

        # Calculate risk score
        severity_weights = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 1
        }

        total_risk_score = sum(
            severity_weights.get(p["severity"], 0) * p["match_count"]
            for p in detected_patterns
        )

        return {
            "total_patterns_detected": len(detected_patterns),
            "detected_patterns": detected_patterns,
            "risk_score": total_risk_score,
            "risk_level": self._calculate_risk_level(total_risk_score),
            "scan_coverage": len(binary_data),
            "library_version": "1.0.0"
        }

    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate overall risk level based on score."""
        if risk_score >= 50:
            return "critical"
        elif risk_score >= 25:
            return "high"
        elif risk_score >= 10:
            return "medium"
        elif risk_score >= 5:
            return "low"
        else:
            return "none"

    def add_pattern(self, pattern: ExploitPattern) -> None:
        """Add a new exploit pattern to the library."""
        self.patterns.append(pattern)

    def get_patterns_by_type(self, pattern_type: str) -> List[ExploitPattern]:
        """Get all patterns of a specific type."""
        return [p for p in self.patterns if p.pattern_type == pattern_type]

    def get_patterns_by_severity(self, severity: str) -> List[ExploitPattern]:
        """Get all patterns of a specific severity."""
        return [p for p in self.patterns if p.severity == severity]


# Global pattern library instance
exploit_pattern_library = ExploitPatternLibrary()